---
layout:     post
title:      项目Tips
subtitle:   
date:       2017-08-28
author:     Joy
header-img: img/page-bg-people.png
catalog: true
tags:
    - Android
---

* 项目第一次打开，从MainActivity跳转到SplashActivity，动画结束之后重新初始化了一个MainActivity
* 一次EventBus事件重复注册Crash
* Wifi列表重复点击问题

#### Android 事件框架 EventBus

EvnetBus 是一个 Android 事件订阅/发布的框架：

![](/img/post-img-eventbus.png)

是Android组件间的通信方案，有以下优势：

* 减少通信的冗余代码


* jar包大小50k
* 速度快
* 支持多种线程模式
* 开源（[EventBusGithub](https://github.com/greenrobot/EventBus)）

##### EventBus配置步骤

* 配置要发送的消息载体类

  ```
  public class MessageEvent {
    	public final String message;
    	public MessageEvent(String message) {
        	this.message = message;
    	}
  }
  ```

* 配置订阅者

  订阅者要实现事件处理方法，这些方法将在事件post之后执行

  ```
  @Subscribe(threadMode = ThreadMode.MAIN)
  public void onMessageEvent(MessageEvent event) {
    	....
  }
  ```

  同时，在订阅者中需要注册和注销操作

  ```
  @Override 
  public void onStart() {
    	super.onStart();
    	EventBus.getDefault().register(this);
  }

  @Override
  public void onStop() {
    	EventBus.getDefault().unregister(this);
    	super.onStop();
  }
  ```

* 发送事件

  ```
  EventBus.getDefault().post(new MessageEvent("Hello EventBus"));
  ```

##### EventBus线程模式

EventBus总共有四种线程模式：

* ThreadMode.MAIN：表示无论哪个线程发布出来的，该订阅方法onEvent都会在UI线程中执行
* ThreadMode.POSTING：事件在哪个线程发出来，事件的订阅函数onEvent就会在这个线程中运行
* ThreadMode.BACKGROUND：事件如果在UI线程中发布出来，订阅函数就会在子线程中运行，如果本来就是在子线程中，则订阅函数就在那个线程中执行
* ThreadMode.AYSNC：无论如何都创建新的子线程来执行订阅函数

##### 注意事项

* 一般是在onCreate和onStart里注册，尽量不要在onResume里面注册，可能出现多次注册的Exception导致crash：

  ```
  ExentBusException: Subscriber class already registered to event class

  // 如果有多次执行的可能，则需要添加判断
  if (!EventBus.getDefault().isRegistered(this)) {
    	EventBus.getDefault().register(this);
  }
  ```

##### EventBus源码分析

* 注册EventBus

  ```
  public void register(Object subscriber) {
    	Class<?> subscriberClass = subscriber.getClass();
    	List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    	synchronized(this) {
        	for(SubscriberMethod subscriberMethod : subscriberMethods) {
            	subscribe(subscriber, subscriberMethod);
        	}
    	}
  }
  ```

  注册这一步把注册者实现的全部的事件响应方法找到，并调用订阅方法，把订阅者和响应方法关联起来

* postEvent

  ```
  public void post(Object event) {
    	PostingThreadState postingState = currentPostingThreadState.get();
    	List<Object> eventQueue = postingState.eventQueue;
    	eventQueue.add(event);
    	if (!postingState.isPosting) {
        	postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
        	postingState.isPosting = true;
        	if (postingState.canceled) {
            	throw new EventBusException("..");
        	}
        	try {
            while(!eventQueue.isEmpty()) {
              	postSingleEvent(eventQueue.remove(0), postingState);
            } fially {
              	postingState.isPosting = false;
              	postingState.isMainThread = false;
            }
        	}
    	}
  }
  ```

* Subscribe.java

  ```
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.METHOD})
  public @interface Subscribe {
    	ThreadMode threadMode() default ThreadMode.POSTING;
    	
    	/**
    	 * If true, deliverys the most recent sticky event (posted with
    	 * {@link EventBus#postSticky(Objecet)}) to this subscriber (if event available).
    	 */
    	 boolean sticky() default false;
    	 
    	 /** 
    	  * Subscriber priority to influence the order of evnet delivery.
    	  * Within the same delivery thread ({@link ThreadMode}), higher priority 
    	  * subscribers will receive events before others with a lower priority.
    	  * The default priority is 0. Note: the priority does *NOT* affect the 
    	  * order of delivery among subscribers with different {@link ThreadMode}s! 
    	  */
    	  int priority() default 0;
  }
  ```

  这里用到了[注解语法](#注解语法)，拿出来归纳一下吧

#### Android 控件注入框架 Butter Knife  

ButterKnife是Android系统的View注入框架，能够通过"注解"的方式来绑定View的属性或方法。

给项目添加ButterKnife比较容易：

* 在Project的build.gradle中添加：

  ```
  dependencies {
    	classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
  }
  ```

* App的build.gradle中添加：

  ```
  apply plugin: 'com.neenbedankt.android-apt'
  dependencies {
    	compile 'com.jakewharton:butterknife:8.0.1'
    	apt 'com.jakewharton:butterknife-compiler:8.0.1'
  }
  ```

在项目中具体使用规则不在这里详述，看[文档](https://jakewharton.github.io/butterknife/)

#### 原理分析

Java Annotation Processing ，注解处理器，在Java5中叫APT。

是一个编译时扫描和解析Java注解的工具，通过它我们可以自己定义注解，并定义解析器来处理它们。它的原理是读入Java源代码，解析注解，然后生成新的Java代码，新生成的代码最后被编译成Java字节码。

##### ButterKnife流程

来看一下@BindView注解的定义：

```
@Retention(CLASS) @Target(FIELD)
public @interface BindView {
  	// View ID to which the field will be bound.
  	@IdRes int value();
}
```

重点在于@Retention(CLASS)，它表示该注解在编译时被保留，但在运行时JVM会忽略它。因而不会对运行时的性能造成影响。

##### 扫描ButterKnife注解

通过注解来声明一个View：

```
@BindView(R.id.text1) TextView textView;
```

在编译的时候，ButterKnifeProcessor类的process()方法便会执行，搜索到所有的ButterKnife注解，然后生成一个Java类。

在app/build/generated/source/apt/中找到生成的MainActivity$$ViewBinder文件，该类中包含了一个bind方法：

```
public Unbinder bind(final Finder finder, final T target, Object source) {
  	InnerUnbinder unbinder = createUnbinder(target);
  	View view;
  	view = finder.findRequiredView(source, 2131492944, "field 'textView'");
  	target.textView = finder.castView(view, 2131492944, "filed 'textView'");
  	return unbinder;
}
```

##### 动态注入

最后当我们执行ButterKnife.bind(this)时，ButterKnife会加载上面生成的类，然后调用bind方法

* 首先是findRequiredView去找R.id.textView对应的控件
* 然后castView类型转换把View换成TextView



### 注解语法

代码注释除了字面上的用途以外，还为开发者在代码中添加信息提供了一种形式化的方法：

* 生成文档
* 跟踪代码依赖性，实现替代配置文件的功能
* 在编译时进行格式检查

##### 创建一个注解

* 注解声明

  ```
  /* @interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数
   * 方法名就是参数的名称，返回值类型就是参数的类型
   * 可以通过default来声明参数的默认值
   * @Retention用来声明注解的保留策略，有CLASS、RUNTIME和SOURCE三中
   * 		分别表示注解保存在类文件、JVM运行时和源代码中
   * 只有当声明在RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息
   * @Target用来声明注解可以被添加在哪些类型的元素上，如类型、方法和域等
   * @Documented将此注解包含在javadoc中，会被提出成文档
   * @Inherited允许子类继承父类中的注解
   */
   
   // 这里举EventBus对事件回调注解的源码
   @Documented
   @Retention(RetentionPolicy.RUNTIME)
   @Target({ElementType.METHOD})
   public @interface Subscribe {
     	Thread threadMode() default ThreadMode.POSTING;
     	boolean sticky() default false;
     	int priority() default 0;
   }
  ```

  ​


* 读取注解的信息

  ```
  Class clazz = Class.forName("xxxx");
  Annotation[] annotations = clazz.getAnnotations();
  for (Annotation annotation : annotations) {
    	Subscribe s = (Subscribe) annotation;
    	// s.sticky();
    	// s.priority();
  }
  ```

##### Java 8 Annotation 新特性

* 在Java 8之前的版本中，只能允许在声明式前使用Annotation。而在Java 8 版本中，Annotation 可以被用在任何使用Type的地方，例如：初始化对象时(new) 对象类型转化时，使用implements表达式时，或者使用throws表达式时。

  ```
  String myString = new @NotNull String();
  myString = (@NonNull String) str;
  class MyList<T> implements @ReadOnly List<@ReadOnly T> {
    	
  }
  public void validateValues() throws @Critical ValidationFailedException {
    
  }
  ```

* Repeaing Annotation

  之前的版本不允许在同一个声明式前加注同样的Annotation




#### 项目管理

* 公司内部项目放在Gitlab上管理
* 只有一个主项目，包含后端代码，客户端代码和前端代码；核心工具类库通过子模块的方式托管在主项目上
  * 子模块的分支和主项目分支约定一一对应（防止测试分支的子模块被带到线上）
* 分支管理
  * **master** 分支用来维护线上的代码
  * 另外需要一个分支，假设就叫**beta**分支，用来做上线前的测试分支
  * 除此之外，个人在开发的时候，可以从master或者beta切一个自己的分支，在自己的分支上完成开发任务之后，与beta分支merge
  * 所有的测试步骤应先在beta上进行（beta在开发的过程中，master可以继续修改，比如有bug紧急线上修改之类的），beta随时与master同步。



#### 开发、测试、上线流程

* 产品制作版本需求原型
  * 需求比较复杂的情况下，需要和研发一起讨论原型，弄清楚基本的可行性和大致实现方案
* 根据原型切分大致的功能模块
  * 可以在gitlab上开一个项目，使用issue系统来罗列各个模块、相关负责人和任务进度
  * 研发可以从beta切出自己分支，在自己的分支上完成开发之后，修改模块的进度状态，然后merge回beta
* 为beta分支搭建测试集群
  * 尽量保证与线上一模一样的环境，整个测试的流程在beta分支的测试集群上完成
  * 各个端的API、域名之类的配置与分支匹配
* 测试、修bug流程
  * 测试需要罗列测试功能点列表，包括新功能点和老的功能点
  * 测试过程中遇到的bug，记录到项目的issue系统中，并添加优先级标签（高、中、低）
  * 研发自己协商认领bug，并标记bug状态（进行中、已处理）和责任人
  * 测试对已处理的bug再次确认之后，删除issue
  * 如果需要检查旧版本App的兼容性，需切回上一个版本打包客户端测试
* 上线流程
  * beta 分支由测试确定功能点完整、全部已知bug都已处理的情况下，由研发将代码merge到master分支
  * 从master分支上打包App安装包，测试简单过一下功能性
  * 提交上线，进程重启后，马上进行线上测试
  * 测试过程中遇到没法短时间解决的严重bug，需马上回滚到上一个版本，修复之后，重新测试、上线

