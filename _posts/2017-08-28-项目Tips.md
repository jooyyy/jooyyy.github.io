---
layout:     post
title:      项目Tips
subtitle:   
date:       2017-08-28
author:     Joy
header-img: img/page-bg-people.png
catalog: true
tags:
    - Android
---

* 项目第一次打开，从MainActivity跳转到SplashActivity，动画结束之后重新初始化了一个MainActivity
* 一次EventBus事件重复注册Crash
* Wifi列表重复点击问题

#### Android 事件框架 EventBus

EvnetBus 是一个 Android 事件订阅/发布的框架：

![](/img/post-img-eventbus.png)

是Android组件间的通信方案，有以下优势：

* 减少通信的冗余代码


* jar包大小50k
* 速度快
* 支持多种线程模式
* 开源（[EventBusGithub](https://github.com/greenrobot/EventBus)）

##### EventBus配置步骤

* 配置要发送的消息载体类

  ```
  public class MessageEvent {
    	public final String message;
    	public MessageEvent(String message) {
        	this.message = message;
    	}
  }
  ```

* 配置订阅者

  订阅者要实现事件处理方法，这些方法将在事件post之后执行

  ```
  @Subscribe(threadMode = ThreadMode.MAIN)
  public void onMessageEvent(MessageEvent event) {
    	....
  }
  ```

  同时，在订阅者中需要注册和注销操作

  ```
  @Override 
  public void onStart() {
    	super.onStart();
    	EventBus.getDefault().register(this);
  }

  @Override
  public void onStop() {
    	EventBus.getDefault().unregister(this);
    	super.onStop();
  }
  ```

* 发送事件

  ```
  EventBus.getDefault().post(new MessageEvent("Hello EventBus"));
  ```

##### EventBus线程模式

EventBus总共有四种线程模式：

* ThreadMode.MAIN：表示无论哪个线程发布出来的，该订阅方法onEvent都会在UI线程中执行
* ThreadMode.POSTING：事件在哪个线程发出来，事件的订阅函数onEvent就会在这个线程中运行
* ThreadMode.BACKGROUND：事件如果在UI线程中发布出来，订阅函数就会在子线程中运行，如果本来就是在子线程中，则订阅函数就在那个线程中执行
* ThreadMode.AYSNC：无论如何都创建新的子线程来执行订阅函数

##### 注意事项

* 一般是在onCreate和onStart里注册，尽量不要在onResume里面注册，可能出现多次注册的Exception导致crash：

  ```
  ExentBusException: Subscriber class already registered to event class

  // 如果有多次执行的可能，则需要添加判断
  if (!EventBus.getDefault().isRegistered(this)) {
    	EventBus.getDefault().register(this);
  }
  ```

##### EventBus源码分析

* 注册EventBus

  ```
  public void register(Object subscriber) {
    	Class<?> subscriberClass = subscriber.getClass();
    	List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    	synchronized(this) {
        	for(SubscriberMethod subscriberMethod : subscriberMethods) {
            	subscribe(subscriber, subscriberMethod);
        	}
    	}
  }
  ```

  注册这一步把注册者实现的全部的事件响应方法找到，并调用订阅方法，把订阅者和响应方法关联起来

* postEvent

  ```
  public void post(Object event) {
    	PostingThreadState postingState = currentPostingThreadState.get();
    	List<Object> eventQueue = postingState.eventQueue;
    	eventQueue.add(event);
    	if (!postingState.isPosting) {
        	postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
        	postingState.isPosting = true;
        	if (postingState.canceled) {
            	throw new EventBusException("..");
        	}
        	try {
            while(!eventQueue.isEmpty()) {
              	postSingleEvent(eventQueue.remove(0), postingState);
            } fially {
              	postingState.isPosting = false;
              	postingState.isMainThread = false;
            }
        	}
    	}
  }
  ```

* Subscribe.java

  ```
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.METHOD})
  public @interface Subscribe {
    	ThreadMode threadMode() default ThreadMode.POSTING;
    	
    	/**
    	 * If true, deliverys the most recent sticky event (posted with
    	 * {@link EventBus#postSticky(Objecet)}) to this subscriber (if event available).
    	 */
    	 boolean sticky() default false;
    	 
    	 /** 
    	  * Subscriber priority to influence the order of evnet delivery.
    	  * Within the same delivery thread ({@link ThreadMode}), higher priority 
    	  * subscribers will receive events before others with a lower priority.
    	  * The default priority is 0. Note: the priority does *NOT* affect the 
    	  * order of delivery among subscribers with different {@link ThreadMode}s! 
    	  */
    	  int priority() default 0;
  }
  ```

  这里用到了[注解语法](#注解语法)，拿出来归纳一下吧

#### Android 控件注入框架 Butter Knife  

ButterKnife是Android系统的View注入框架，能够通过"注解"的方式来绑定View的属性或方法。

给项目添加ButterKnife比较容易：

* 在Project的build.gradle中添加：

  ```
  dependencies {
    	classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
  }
  ```

* App的build.gradle中添加：

  ```
  apply plugin: 'com.neenbedankt.android-apt'
  dependencies {
    	compile 'com.jakewharton:butterknife:8.0.1'
    	apt 'com.jakewharton:butterknife-compiler:8.0.1'
  }
  ```

在项目中具体使用规则不在这里详述，看[文档](https://jakewharton.github.io/butterknife/)

#### 原理分析

Java Annotation Processing ，注解处理器，在Java5中叫APT。

是一个编译时扫描和解析Java注解的工具，通过它我们可以自己定义注解，并定义解析器来处理它们。它的原理是读入Java源代码，解析注解，然后生成新的Java代码，新生成的代码最后被编译成Java字节码。

##### ButterKnife流程

来看一下@BindView注解的定义：

```
@Retention(CLASS) @Target(FIELD)
public @interface BindView {
  	// View ID to which the field will be bound.
  	@IdRes int value();
}
```

重点在于@Retention(CLASS)，它表示该注解在编译时被保留，但在运行时JVM会忽略它。因而不会对运行时的性能造成影响。

##### 扫描ButterKnife注解

通过注解来声明一个View：

```
@BindView(R.id.text1) TextView textView;
```

在编译的时候，ButterKnifeProcessor类的process()方法便会执行，搜索到所有的ButterKnife注解，然后生成一个Java类。

在app/build/generated/source/apt/中找到生成的MainActivity$$ViewBinder文件，该类中包含了一个bind方法：

```
public Unbinder bind(final Finder finder, final T target, Object source) {
  	InnerUnbinder unbinder = createUnbinder(target);
  	View view;
  	view = finder.findRequiredView(source, 2131492944, "field 'textView'");
  	target.textView = finder.castView(view, 2131492944, "filed 'textView'");
  	return unbinder;
}
```

##### 动态注入

最后当我们执行ButterKnife.bind(this)时，ButterKnife会加载上面生成的类，然后调用bind方法

* 首先是findRequiredView去找R.id.textView对应的控件
* 然后castView类型转换把View换成TextView

###注解语法

代码注释除了字面上的用途以外，还为开发者在代码中添加信息提供了一种形式化的方法：

* 生成文档
* 跟踪代码依赖性，实现替代配置文件的功能
* 在编译时进行格式检查

##### 创建一个注解

* ```
  /* @interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数
   * 方法名就是参数的名称，返回值类型就是参数的类型
   * 可以通过default来声明参数的默认值
   * @Retention用来声明注解的保留策略，有CLASS、RUNTIME和SOURCE三中
   * 		分别表示注解保存在类文件、JVM运行时和源代码中
   * 只有当声明在RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息
   * @Target用来声明注解可以被添加在哪些类型的元素上，如类型、方法和域等
   * @Documented将此注解包含在javadoc中，会被提出成文档
   * @Inherited允许子类继承父类中的注解
   */
   
   // 这里举EventBus对事件回调注解的源码
   @Documented
   @Retention(RetentionPolicy.RUNTIME)
   @Target({ElementType.METHOD})
   public @interface Subscribe {
     	Thread threadMode() default ThreadMode.POSTING;
     	boolean sticky() default false;
     	int priority() default 0;
   }
  ```

* 读取注解的信息

  ```
  Class clazz = Class.forName("xxxx");
  Annotation[] annotations = clazz.getAnnotations();
  for (Annotation annotation : annotations) {
    	Subscribe s = (Subscribe) annotation;
    	// s.sticky();
    	// s.priority();
  }
  ```

##### Java 8 Annotation 新特性

* 在Java 8之前的版本中，只能允许在声明式前使用Annotation。而在Java 8 版本中，Annotation 可以被用在任何使用Type的地方，例如：初始化对象时(new) 对象类型转化时，使用implements表达式时，或者使用throws表达式时。

  ```
  String myString = new @NotNull String();
  myString = (@NonNull String) str;
  class MyList<T> implements @ReadOnly List<@ReadOnly T> {
    	
  }
  public void validateValues() throws @Critical ValidationFailedException {
    
  }
  ```

* Repeaing Annotation

  之前的版本不允许在同一个声明式前加注同样的Annotation

