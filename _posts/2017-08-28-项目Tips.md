---
layout:     post
title:      项目Tips
subtitle:   
date:       2017-08-28
author:     Joy
header-img: img/page-bg-people.png
catalog: true
tags:
    - Android
---

* 项目第一次打开，从MainActivity跳转到SplashActivity，动画结束之后重新初始化了一个MainActivity
* 一次EventBus事件重复注册Crash
* Wifi

#### Android 事件框架 EventBus

EvnetBus 是一个 Android 事件订阅/发布的框架：

![](img/post-img-eventbus.png)

是Android组件间的通信方案，有以下优势：

* 减少通信的冗余代码


* jar包大小50k
* 速度快
* 支持多种线程模式
* 开源（[EventBusGithub](https://github.com/greenrobot/EventBus)）

##### EventBus线程模式

EventBus总共有四种线程模式：

* ThreadMode.MAIN：表示无论哪个线程发布出来的，该订阅方法onEvent都会在UI线程中执行
* ThreadMode.POSTING：事件在哪个线程发出来，事件的订阅函数onEvent就会在这个线程中运行
* ThreadMode.BACKGROUND：事件如果在UI线程中发布出来，订阅函数就会在子线程中运行，如果本来就是在子线程中，则订阅函数就在那个线程中执行
* ThreadMode.AYSNC：无论如何都创建新的子线程来执行订阅函数

##### 注意事项

* 一般是在onCreate和onStart里注册，尽量不要在onResume里面注册，可能出现多次注册的Exception导致crash：

  ```
  ExentBusException: Subscriber class already registered to event class

  // 如果有多次执行的可能，则需要添加判断
  if (!EventBus.getDefault().isRegistered(this)) {
    	EventBus.getDefault().register(this);
  }
  ```

  ​

##### EventBus源码分析



#### Android 控件注入框架 Butter Knife  

ButterKnife是Android系统的View注入框架，能够通过"注解"的方式来绑定View的属性或方法。

给项目添加ButterKnife比较容易：

* 在Project的build.gradle中添加：

  ```
  dependencies {
    	classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
  }
  ```

* App的build.gradle中添加：

  ```
  apply plugin: 'com.neenbedankt.android-apt'
  dependencies {
    	compile 'com.jakewharton:butterknife:8.0.1'
    	apt 'com.jakewharton:butterknife-compiler:8.0.1'
  }
  ```

在项目中具体使用规则不在这里详述，看[文档](https://jakewharton.github.io/butterknife/)

#### 原理分析

Java Annotation Processing ，注解处理器，在Java5中叫APT。

是一个编译时扫描和解析Java注解的工具，通过它我们可以自己定义注解，并定义解析器来处理它们。它的原理是读入Java源代码，解析注解，然后生成新的Java代码，新生成的代码最后被编译成Java字节码。

##### ButterKnife流程

来看一下@BindView注解的定义：

```
@Retention(CLASS) @Target(FIELD)
public @interface BindView {
  	// View ID to which the field will be bound.
  	@IdRes int value();
}
```

重点在于@Retention(CLASS)，它表示该注解在编译时被保留，但在运行时JVM会忽略它。因而不会对运行时的性能造成影响。

##### 扫描ButterKnife注解

通过注解来声明一个View：

```
@BindView(R.id.text1) TextView textView;
```

在编译的时候，ButterKnifeProcessor类的process()方法便会执行，搜索到所有的ButterKnife注解，然后生成一个Java类。

在app/build/generated/source/apt/中找到生成的MainActivity$$ViewBinder文件，该类中包含了一个bind方法：

```
public Unbinder bind(final Finder finder, final T target, Object source) {
  	InnerUnbinder unbinder = createUnbinder(target);
  	View view;
  	view = finder.findRequiredView(source, 2131492944, "field 'textView'");
  	target.textView = finder.castView(view, 2131492944, "filed 'textView'");
  	return unbinder;
}
```

##### 动态注入

最后当我们执行ButterKnife.bind(this)时，ButterKnife会加载上面生成的类，然后调用bind方法

* 首先是findRequiredView去找R.id.textView对应的控件
* 然后castView类型转换把View换成TextView

