---
layout:     post
title:      Android 四大组件归纳
subtitle:   
date:       2017-09-04
author:     Joy
header-img: img/page-bg-people.png
catalog: true
tags:
    - Android
---

#### Broadcasts

> 安卓应用可以发送或者从系统或者其他的Apps接收广播消息，与订阅|发布模式相同。当有意义的事情发生的时候，广播被发送。比如系统完成启动、开始充电、打开飞行模式等，同样的其他的Apps也可以发送广播，比如，当数据完成下载之后

* System broadcasts

  广播消息被 Intent 对象封装，使用 action 字符串来区分发生的事件，比如

  > android.intent.action.AIRPLANE_MODE

* Android 7.0 broadcasts 方面的调整

  系统不再发送下列系统广播

  * ACTION_NEW_PICTURE
  * ACTION_NEW_VIDEO

  API level 24以及更高的版本在注册CONNETIVITY_ACTION时，必须使用registerReceiver(BroadcastReceiver, IntentFilter)，仅仅在 manifest 里注册已经不起作用。

##### 接收广播

* 在 Manifest 文件中注册

  * 添加 <receiver> 描述

    ```
    <receiver android:name=".XXBroadcastReceiver" android:exported="true">
    	<intent-filter>
    		<action android:name="android.intent.action.BOOT_COMPLETED"/>
    		<action android:name="android.intent.action.INPUT_METHOD_CHANGED"/>
    	
    	....
    </receiver>
    ```

  * 继承 BroadcastReceiver 并实现 onReceive(Context, Intent)

    ```
    public class XXBroadcastReceiver extends BroadcastReceiver {
    	@Override
    	public void onReceive(Context context, Intent intent) {
       		...
    	}
    }
    ```

  > 系统的包管理器会在应用安装好的时候注册这些 receiver，所以这些 receiver 会与app 完全分离，就是说系统可以打开应用发送广播，即使在应用没有启动的情况下。
  >
  > 系统会创建一个新的 **BroadcastReceiver**组件去处理每次收到的广播

* 使用 context 注册

  * 创建一个 BroadcastReceiver

    ````
    BroadcastReceiver br = new XXBroadcastReceiver();
    ````

  * 创建一个 IntentFilter，通过registerReceiver(BroadcastReceiver, IntentFilter)注册receiver

    ```
    IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
    intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
    this.registerReceiver(br, filter);
    ```

  > 注意：如果要注册一个本地广播的话，调用LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)
  >
  > ​
  >
  > 通过 context 注册的广播接收器，生命周期和 context 是同步的。

  * 调用 unregisterReceiver(android.content.BroadcastReceiver 来停止接收广播

  > 注意：在onReceiver调用之后 系统会回收资源，一般不要在receiver中做耗时操作，一定要做，需要调用goAsync()或者 使用JobScheduler 开启一个 JobService

  ```
  public class MyBroadcastReceiver extends BroadcastReceiver {
      private static final String TAG = "MyBroadcastReceiver";

      @Override
      public void onReceive(final Context context, final Intent intent) {
          final PendingResult pendingResult = goAsync();
          AsyncTask<String, Integer, String> asyncTask = new AsyncTask<String, Integer, String>() {
              @Override
              protected String doInBackground(String... params) {
                  StringBuilder sb = new StringBuilder();
                  sb.append("Action: " + intent.getAction() + "\n");
                  sb.append("URI: " + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + "\n");
                  Log.d(TAG, log);
                  // Must call finish() so the BroadcastReceiver can be recycled.
                  pendingResult.finish();
                  return data;
              }
          };
          asyncTask.execute();
      }
  }

  ```

  ​

  ​