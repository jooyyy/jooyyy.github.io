---
layout:     post
title:      Java基础归纳
subtitle:   
date:       2017-08-29
author:     Joy
header-img: img/page-bg-people.png
catalog: true
tags:
    - Java
---

## Java中的final关键字归纳

##### 含义

final在Java中是一个保留的关键字，可以声名成员变量、方法、类以及本地变量。一旦将引用声明作final，就不能再改变这个引用，编译器会检查代码，如果有多次初始化，会报错。

##### final 变量

凡是对成员变量或者本地变量声明为final都叫作final变量。final变量经常和static关键字一起使用，代表常量。

##### final 方法

方法前面加上final关键字，代表这个方法不能被子类重写。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。

##### final 类

用final来修饰的类叫作final类。final类通常功能是完整的，不能被继承，譬如String，Interger

##### final 关键字的好处

* final关键字提高了性能，JVM和Java应用都会缓存final变量
* final变量可以安全在多线程的环境下共享，不需要额外的同步开销
* 使用final关键字，JVM会对方法、变量进行优化

##### final 重要知识点

* final 关键字可以用于成员变量、本地变量、方法以及类
* final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报错
* 不能对final变量再次赋值
* 在匿名类中所有变量都必须是final变量
* final 方法不能被重写
* final 类不能被继承
* final 关键字不用于 finally 关键字，后者用于异常处理
* final 关键字不同于 finalize()， 后者实在Object类中定义的方法，是垃圾回收之前被JVM调用的方法
* 借口中声明的所有变量本身是final的
* final 和 abstract 是相反的
* final 方法在编译阶段绑定，称为静态绑定
* 没有在声明时初始化的 final 变量称为空白 final 变量，它们必须在构造器中初始化，或者调用this()初始化
* 将类、方法、变量声明为final能提高性能，这样JVM就有机会进行评估，然后优化
* 按照Java代码的惯例，final变量就是常量，而且通常常量名要大写



## Java 内部类

##### 含义

顾名思义啰

##### 为什么要使用内部类

> 《Think in java》中说：**使用内部类最新引人的原因是：每个内部类都能独立继承一个（接口）实现，所以无论外围类是否已经继承了某个实现，对于内部类都没有影响**

##### 内部类基础

* 成员内部类

  * 是外围类的一个成员，可以无限制访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类的实例来访问
  * **成员内部类中不能存在任何static的变量和方法**
  * 成员内部类依附于外围类，只有先创建了外围类才能够创建内部类

* 局部内部类

  * 嵌套在方法和作用域内，用于在解决复杂问题的时候，创建一个类来辅助解决问题

* 匿名内部类

  ```
  public class OuterClass {
    	public InnerClass getInnerClass(final int num, String string) {
        	return new InnerClass() {
            	int number = num + 3;
            	public int getNumber() {
                	return number;
            	}
        	}
    	};
    	
    	public static void main(String[] args) {
        	OuterClass out = new OuterClass();
        	InnerClass inner = out.getInnerClass(2, "chenssy");
    	}
  }

  interface InnerClass() {
    	int getNumber();
  }
  ```

  注意事项：

  * 使用匿名内部类时，我们必须继承一个类或者实现一个接口，但是两者不可兼得


  * 匿名内部类是没有访问修饰符的
  * 匿名内部类中不能存在任何静态成员变量和静态方法
  * 注意getInnerClass()方法的形参，第一个形参是用final修饰的，第二个没有。同时第二个形参在匿名内部类中没有使用过，所以当所有在方法的形参需要被匿名内部类使用，那个形参必须为final
    * 内部类编译成功后，会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。拷贝了引用，为了避免引用值发生改变，用final来避免
  * 匿名内部类没有构造方法

* 静态内部类

  * 静态内部类和非静态内部类之间最大的区别在于，非静态在编译完成之后会隐含地保留一个创建它的外围类的引用，而静态内部类没有
    * 它的创建不需要依赖外围类
    * 它不能使用任何外围类的非static成员变量和方法

## abstract class 和 interface 归纳

abstract class 和 interface 在Java语言中都是用来进行抽象体定义的。

#### 从语法定义层面看

* 使用abstract class定义Demo抽象类

  ```
  abstract class Demo {
    	abstract void method1();
    	void method2();
    	...
  }
  ```

* 使用interface定义Demo抽象类

  ```
  interface Demo {
    	void method1();
    	void method2();
    	...
  }
  ```

可以看出，abstract class方式中，Demo可以有自己的数据成员，也可以有非abstract的成员方法，而在interface方式中，Demo只能够有静态不能被修改的数据成员，也就是必须是static final的，所有的成员方法都是abstract的。

#### 从编程层面看

abstract class和interface都可以用来实现“契约式”的思想，但在具体使用上稍有区别。

* abstract class 表示一种继承关系，一个类只能使用一次继承关系，但是却可以实现多个interface。

* abstract class 可以赋予方法的默认行为，但是interface中不行

  * 如果Java的抽象体中不能存在默认行为，那么后面如果想修改类的功能，比如添加一个参数，就会非常不好用，但是通过abstract class来实现，那就只需要修改定义在abstract class中的默认行为就可以了
  * 并且，如果没有默认行为，会导致同样的方法实现出现在该抽象类的每一个派生类中，造成代码重复

  ```
  // 这里举一个例子，Android中的View的click事件由OnClickListener来监听，比较常见的interface，只有一个void onClick(View v)的成员方法；实际开发中常遇到View被快速点击多次的问题，解决方案马上可以想到比如说写一个计时器，前后点击1000ms以内直接返回。一个很基础的方案，可能很多地方都用得上，当然可以直接在onClick中去实现，不过这样就违背了Java的“one rule, one place”原则，每个View的点击事件都要重新实现一次这个功能吗？当然，可以把避免短时间连续点击作为一个默认行为添加到abstract class中，下面是实现

  public abstract class NoDoubleOnClickListener implements View.OnClickListener {
    	public static final DELAY = 1000;
    	private long lastClickTime = 0;
    	
    	@Override
    	public void onClick(View v) {
        	long currentTime = System.currentTimeMillis();
        	if (currentTime - lastClickTime > DELAY) {
            lastClickTime = currentTime;
            noDoubleClick(v);
        	}
    	}
    	
    	public abstract void noDoubleClick(View v);
  }
  ```



#### 从设计理念层面看

这个瞬间就有高度了。

abstarct class在Java语言中体现了一种继承关系，要使得继承关系合理，则父类和派生类之间必须本质上是相同的，这对于interface来说，是没有这一层意思的，interface的实现仅仅只是实现了定义的契约。