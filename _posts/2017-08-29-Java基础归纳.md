---
layout:     post
title:      Java基础归纳
subtitle:   
date:       2017-08-29
author:     Joy
header-img: img/page-bg-people.png
catalog: true
tags:
    - Java
---

## Java中关键字归纳

#### final 关键字

##### final含义

final在Java中是一个保留的关键字，可以声名成员变量、方法、类以及本地变量。一旦将引用声明作final，就不能再改变这个引用，编译器会检查代码，如果有多次初始化，会报错。

##### final 变量

凡是对成员变量或者本地变量声明为final都叫作final变量。final变量经常和static关键字一起使用，代表常量。

##### final 方法

方法前面加上final关键字，代表这个方法不能被子类重写。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。

##### final 类

用final来修饰的类叫作final类。final类通常功能是完整的，不能被继承，譬如String，Interger

##### final 关键字的好处

* final关键字提高了性能，JVM和Java应用都会缓存final变量
* final变量可以安全在多线程的环境下共享，不需要额外的同步开销
* 使用final关键字，JVM会对方法、变量进行优化

##### final 重要知识点

* final 关键字可以用于成员变量、本地变量、方法以及类

* final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报错

* 不能对final变量再次赋值

* 在匿名类中所有变量都必须是final变量

* final 方法不能被重写

* final 类不能被继承

* final 关键字不用于 finally 关键字，后者用于异常处理

* final 关键字不同于 finalize()， 后者实在Object类中定义的方法，是垃圾回收之前被JVM调用的方法

* 借口中声明的所有变量本身是final的

* final 和 abstract 是相反的

* final 方法在编译阶段绑定，称为静态绑定

* 没有在声明时初始化的 final 变量称为空白 final 变量，它们必须在构造器中初始化，或者调用this()初始化

* 将类、方法、变量声明为final能提高性能，这样JVM就有机会进行评估，然后优化

* 按照Java代码的惯例，final变量就是常量，而且通常常量名要大写

  ​

#### synchronized

用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码

* 当两个并发线程访问同一个对象中的这个synchronized(this)同步代码块的时候，同一时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块

* 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程任然可以访问该object中的非synchronized(this)代码块

  ​

#### Volatiel 变量

vaolatiel 变量可以被看作是一种“程度较轻的synchronized”，可用于提供线程安全

##### 正确使用条件

* 对变量的写操作不依赖当前值
* 该变量没有包含在具有其他变量的不变式中

以上条件表明，可以被写入volatile变量的这些有效值独立于任何程序的状态，包括变量的当前状态。

> 第一个条件的限制使volatile变量不能用作线程安全计数器。虽然增量操作x++看上去类似一个独立操作，实际上它是由读取-修改-写入操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必须的原子特性。实现正确的操作需要使x的值在操作期间保持不变。

##### 正确使用volatile的模式

* 状态标志
  * 也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件
* 一次性安全发布
* 独立观察

## Java 内部类

##### 含义

顾名思义啰

##### 为什么要使用内部类

> 《Think in java》中说：**使用内部类最新引人的原因是：每个内部类都能独立继承一个（接口）实现，所以无论外围类是否已经继承了某个实现，对于内部类都没有影响**

##### 内部类基础

* 成员内部类

  * 是外围类的一个成员，可以无限制访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类的实例来访问
  * **成员内部类中不能存在任何static的变量和方法**
  * 成员内部类依附于外围类，只有先创建了外围类才能够创建内部类

* 局部内部类

  * 嵌套在方法和作用域内，用于在解决复杂问题的时候，创建一个类来辅助解决问题

* 匿名内部类

  ```
  public class OuterClass {
    	public InnerClass getInnerClass(final int num, String string) {
        	return new InnerClass() {
            	int number = num + 3;
            	public int getNumber() {
                	return number;
            	}
        	}
    	};
    	
    	public static void main(String[] args) {
        	OuterClass out = new OuterClass();
        	InnerClass inner = out.getInnerClass(2, "chenssy");
    	}
  }

  interface InnerClass() {
    	int getNumber();
  }
  ```

  注意事项：

  * 使用匿名内部类时，我们必须继承一个类或者实现一个接口，但是两者不可兼得


  * 匿名内部类是没有访问修饰符的
  * 匿名内部类中不能存在任何静态成员变量和静态方法
  * 注意getInnerClass()方法的形参，第一个形参是用final修饰的，第二个没有。同时第二个形参在匿名内部类中没有使用过，所以当所有在方法的形参需要被匿名内部类使用，那个形参必须为final
    * 内部类编译成功后，会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。拷贝了引用，为了避免引用值发生改变，用final来避免
  * 匿名内部类没有构造方法

* 静态内部类

  * 静态内部类和非静态内部类之间最大的区别在于，非静态在编译完成之后会隐含地保留一个创建它的外围类的引用，而静态内部类没有
    * 它的创建不需要依赖外围类
    * 它不能使用任何外围类的非static成员变量和方法

## abstract class 和 interface 归纳

abstract class 和 interface 在Java语言中都是用来进行抽象体定义的。

#### 从语法定义层面看

* 使用abstract class定义Demo抽象类

  ```
  abstract class Demo {
    	abstract void method1();
    	void method2();
    	...
  }
  ```

* 使用interface定义Demo抽象类

  ```
  interface Demo {
    	void method1();
    	void method2();
    	...
  }
  ```

可以看出，abstract class方式中，Demo可以有自己的数据成员，也可以有非abstract的成员方法，而在interface方式中，Demo只能够有静态不能被修改的数据成员，也就是必须是static final的，所有的成员方法都是abstract的。

#### 从编程层面看

abstract class和interface都可以用来实现“契约式”的思想，但在具体使用上稍有区别。

* abstract class 表示一种继承关系，一个类只能使用一次继承关系，但是却可以实现多个interface。

* abstract class 可以赋予方法的默认行为，但是interface中不行

  * 如果Java的抽象体中不能存在默认行为，那么后面如果想修改类的功能，比如添加一个参数，就会非常不好用，但是通过abstract class来实现，那就只需要修改定义在abstract class中的默认行为就可以了
  * 并且，如果没有默认行为，会导致同样的方法实现出现在该抽象类的每一个派生类中，造成代码重复

  ```
  // 这里举一个例子，Android中的View的click事件由OnClickListener来监听，比较常见的interface，只有一个void onClick(View v)的成员方法；实际开发中常遇到View被快速点击多次的问题，解决方案马上可以想到比如说写一个计时器，前后点击1000ms以内直接返回。一个很基础的方案，可能很多地方都用得上，当然可以直接在onClick中去实现，不过这样就违背了Java的“one rule, one place”原则，每个View的点击事件都要重新实现一次这个功能吗？当然，可以把避免短时间连续点击作为一个默认行为添加到abstract class中，下面是实现

  public abstract class NoDoubleOnClickListener implements View.OnClickListener {
    	public static final DELAY = 1000;
    	private long lastClickTime = 0;
    	
    	@Override
    	public void onClick(View v) {
        	long currentTime = System.currentTimeMillis();
        	if (currentTime - lastClickTime > DELAY) {
            lastClickTime = currentTime;
            noDoubleClick(v);
        	}
    	}
    	
    	public abstract void noDoubleClick(View v);
  }
  ```



#### 从设计理念层面看

abstarct class在Java语言中体现了一种继承关系，要使得继承关系合理，则父类和派生类之间必须本质上是相同的，这对于interface来说，是没有这一层意思的，interface的实现仅仅只是实现了定义的契约。



## Java 泛型归纳

##### 概念

泛型是一种编译器机制，可以通过该机制获取通用的代码并参数化剩余部分，**从而以一种一般化方式创建和使用一些类型的实体**，比如说类或接口和方法。

##### enum 类型

表示一组与某个特定概念相关的常量对象，每个对象都表示该集合中的一个不同的常量值

类与enum的区别是，enum的构造方法必须声明为private，而且它无法扩展或继承其他的enum，但是一个enum可以实现一个接口



## Hash 表这一组团的概念归纳

##### 什么是哈希表

哈希表是一种以 键-值(key-indexed)存储数据的结构，我们只要输入待查找的值（即key），即可查找到其对应的值。

想法是这样的，如果所有的键都是整数，那么久可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，将其扩展到可以处理更加复杂的类型的键。

使用哈希查找有两个步骤：

* 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突
* 处理哈希碰撞冲突。拉链法和线性探测法

##### 哈希函数

如果我们有一个保存0-M的数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。

在实际中，我们的键斌不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。

* 正整数

  获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。

* 字符串

  将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如

  ```
  public int GetHashCode(string str) {
    	char[] s = str.ToCharArray();
    	int hash = 0;
    	for (int i = 0; i < s.Length; i++) {
        	hash = s[i] + (31 * hash);
    	}
    	return hash;
  }
  ```

##### 避免哈希冲突

* 拉链法

  ![](/img/post-img-hash-separate.png)

* 线性探测法

  基本原理为，使用大小为M的数组来保存N个键值对，其中M>N，我们需要使用数组中的空位解决碰撞冲突

  ![](/img/post-img-hash-linear.png)

  开放寻址法解决hash碰撞的最简单的方案，遇到被占用的情况，直接检查散列表中的下一个位置

#### HashMap 概述

HashMap是基于哈希表的Map接口的非同步实现。

HashMap的底层是一个数组结构，数组中的每一项又是一个链表。

```
public HashMap(int initialCapacity, float loadFactor) {
  	if (initialCapacity < 0) {
      	throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
  	}
  	if (initialCapacity > MAXIMUM_CAPACITY) {
      	initialCapacity = MAXIMUM_CAPACITY;
  	}
  	if (loadFactor <= 0 || Float.isNaN(loadFactor)) {
      	throw new sIllegalArgumentException("Illegal load factor: " + loadFactor);
  	}
  	int capacity = 1;
  	while (capacity < initialCapacity) {
      capacity <<= 1;
  	}
  	this.loadFactor = loadFactor;
  	threshold = (int) (capacity * loadFactor);
  	table = new Entry[capacity];
  	init();
}

static class Entry<K,V> implements Map.Entry<K,V> {
  	final K key;
  	V value;
  	Entry<K,V> next;
  	final int hash;
  	
  	Entry(int h, K k, V v, Entry<K,V> n) {
      	value = v;
      	next = n;
      	key = k;
      	hash = h;
  	}
  	......
}
```

##### HashMap的存储实现

```
public V put(K key, V value) {
  	if (key == null) {
      	return putForNullKey(value);
  	}
  	int hash = hash(key.hashCode());
  	int i = indexFor(hash, table.length);
  	for (Entry<K,V> e = table[i]; e != null; e = e.next) {
      	Object k;
      	if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
          V oldValue = e.value;
          e.value = value;
          e.recordAcccess(this);
          return oldValue;
      	}
  	}
  	modCount++;
  	addEntry(hash, key, value, i);
  	return null;
}
```

#### HashSet 实现原理

基于HashMap，HashSet底层使用HashMap来保存所有元素