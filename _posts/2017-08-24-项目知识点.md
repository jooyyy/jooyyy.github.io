---
layout:     post
title:      项目知识点
subtitle:   
date:       2017-08-24
author:     Joy
header-img: img/page-bg-people.png
catalog: true
tags:
    - Linux
---
#### 广播通知详解

Broadcast是Android中进程间通信的一种机制，”四大组件“之一的BroadcastReceiver是对发送出来的Broadcast进行过滤、接受和响应的组件。

##### 广播的工作流程

* 发送者将要发送的消息和用于过滤的信息（Action, Category)装入一个Intent对象
* 通过Context.sendBroadcast()、sendOrderBroadcast()方法把Intent对象以广播形式发送出去
* 所有注册的BroadcastReceiver会检查注册时的IntentFilter是否与发送的Intent相匹配，若匹配，则调用onReceiver()

##### 概念

* 标准广播

  > 完全异步执行的广播，广播发送之后所有的Receiver会在同一时间接收到这条广播，之间没有先后顺序，效率告，无法被截断

* 有序广播

  > 同步执行的广播，在广播发出之后同一时刻只有一个Receiver能够接收到，优先级高的Receiver会优先接收，当优先级高的Recever的onReceiver()调用之后，广播才会继续传递，且前面的广播接收器可以选择截断广播

* 静态注册

  > 在Manifest文件中使用<receiver>标签声明，并在标签内使用<intent-filter>标签设置过滤器。静态注册的Receiver生命周期伴随整个应用，如果这种方式处理的是系统广播，那么不管应用是否在运行，该广播接收器都能接收到该广播

  实例：

  ```
  // 创建Receiver
  public class NormalReceiver extends BroadcastReceiver {
    	public NormlaReceiver(){}
    	@Override
    	public void onReceive(Context context, Intent intent) {
        	String msg = intent.getStringExtra("Msg");
        	...
          // 有序Receiver会在这里对消息进行处理，决定是否继续转发
          // Bundle bundle = new Bundle();
         	// bundle.putString("Data", "new msg");
         	// setResultExtras(bundle);
    	}
  }
  ```

  ```
  // 发送广播
  public class MainActivity ... {
    	private final String NORMAL_ACTION = "com.example.normal.receiver";
    	...
    	void sendBroadcast() {
        	Intent intent = new Intent(NORMAL_ACTION);
        	intent.putExtra("Msg", "Hi");
        	sendBroadcast(intent);
        	// 有序广播调用sendOrderedBroadcast(intent, null);
    	}
  }
  ```

  ```
  // 注册
  <application
  	...
  	<receiver android:name=".NormalReceiver">
  		<intent-filter> 
  		// 有序广播会在<intent-filter android:priority="100"> 填入权重
  			<action android:name="com.example.normal.receiver"/>
  			....
  </application>
  ```

* 动态注册

  > 在Receiver中定义并设置好一个IntentFilter对象，然后在需要注册的地方调用Context.registerReceiver()方法，调用Context.unregisterReceiver()方法取消注册，不需要在Manifest中声明

* 本地广播

  > 只在应用内传播的广播，没法静态注册

*  私有权限

  > 通过动态注册的Receiver存在一个问题，设备上任何应用都可以监听并触发Receiver。
  >
  > 在<receiver>标签中添加android:exported="false"属性来标识仅限内部使用



#### Android Intent详解

##### Intent 概念

>  intent是一种运行时绑定机制，能再程序运行的过程中连接两个不同的组件，是App之间、App内部组件之间的介质。

##### Intent 属性

* component ：显式
* action：Manifest中指定，一个intent filter可以有多个action
* category
* data：用一个uri对象来表示
* type
* extras
* Flags

#### Android Wi-Fi 编程

Android提供了android.net.wifi包，让开发者可以方便的管理设备底层无线堆栈

开发过程中可能需要的权限

* ACCESS_WIFI_STATE
* CHANGE_WIFI_STATE
* CHANGE_WIFI_MULTICAST_STATE

要注意的是**不是所有的Android设备都提供Wi-Fi功能，**所以你可能需要在Manifest里面添加一个元素：

```
<manifest...>
	<uses-feature android:name="android.hardware.wifi" />
	...
</manifest>
```



##### 常用Classes

| [ScanResult](https://developer.android.com/reference/android/net/wifi/ScanResult.html) | Describes information about a detected access point. |
| ---------------------------------------- | ---------------------------------------- |
| [WifiConfiguration](https://developer.android.com/reference/android/net/wifi/WifiConfiguration.html) | A class representing a configured Wi-Fi network, including the security configuration. |
| [WifiConfiguration.AuthAlgorithm](https://developer.android.com/reference/android/net/wifi/WifiConfiguration.AuthAlgorithm.html) | Recognized IEEE 802.11 authentication algorithms. |
| [WifiConfiguration.GroupCipher](https://developer.android.com/reference/android/net/wifi/WifiConfiguration.GroupCipher.html) | Recognized group ciphers.                |
| [WifiConfiguration.KeyMgmt](https://developer.android.com/reference/android/net/wifi/WifiConfiguration.KeyMgmt.html) | Recognized key management schemes.       |
| [WifiConfiguration.PairwiseCipher](https://developer.android.com/reference/android/net/wifi/WifiConfiguration.PairwiseCipher.html) | Recognized pairwise ciphers for WPA.     |
| [WifiConfiguration.Protocol](https://developer.android.com/reference/android/net/wifi/WifiConfiguration.Protocol.html) | Recognized security protocols.           |
| [WifiConfiguration.Status](https://developer.android.com/reference/android/net/wifi/WifiConfiguration.Status.html) | Possible status of a network configuration. |
| [WifiEnterpriseConfig](https://developer.android.com/reference/android/net/wifi/WifiEnterpriseConfig.html) | Enterprise configuration details for Wi-Fi. |
| [WifiEnterpriseConfig.Eap](https://developer.android.com/reference/android/net/wifi/WifiEnterpriseConfig.Eap.html) | The Extensible Authentication Protocol method used |
| [WifiEnterpriseConfig.Phase2](https://developer.android.com/reference/android/net/wifi/WifiEnterpriseConfig.Phase2.html) | The inner authentication method used     |
| [WifiInfo](https://developer.android.com/reference/android/net/wifi/WifiInfo.html) | Describes the state of any Wifi connection that is active or is in the process of being set up. |
| [WifiManager](https://developer.android.com/reference/android/net/wifi/WifiManager.html) | This class provides the primary API for managing all aspects of Wi-Fi connectivity. |
| [WifiManager.LocalOnlyHotspotCallback](https://developer.android.com/reference/android/net/wifi/WifiManager.LocalOnlyHotspotCallback.html) | Callback class for applications to receive updates about the LocalOnlyHotspot status. |
| [WifiManager.LocalOnlyHotspotReservation](https://developer.android.com/reference/android/net/wifi/WifiManager.LocalOnlyHotspotReservation.html) | LocalOnlyHotspotReservation that contains the `WifiConfiguration` for the active LocalOnlyHotspot request. |
| [WifiManager.MulticastLock](https://developer.android.com/reference/android/net/wifi/WifiManager.MulticastLock.html) | Allows an application to receive Wifi Multicast packets. |
| [WifiManager.WifiLock](https://developer.android.com/reference/android/net/wifi/WifiManager.WifiLock.html) | Allows an application to keep the Wi-Fi radio awake. |
| [WifiManager.WpsCallback](https://developer.android.com/reference/android/net/wifi/WifiManager.WpsCallback.html) | Interface for callback invocation on a start WPS action |
| [WpsInfo](https://developer.android.com/reference/android/net/wifi/WpsInfo.html) | A class representing Wi-Fi Protected Setup |



### Android 中的 Context 详解

> Interface to global information about an application environment.This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents.

Context 是一个抽象类，下面看几个该类的实现，它们之间的关系如图：

![context](/img/post-androidcontext.png)

* ContextImpl ，给Activity以及其他的组件提供context对象

  ```
  class ContextImpl extends Context {
      // 所有Application 程序共用一个mPackageInfo对象
      ActivityThread.PackageInfo mPackageInfo;
      
      @Override
      public Object getSystemService(String name) {
          ...
          else if (ACTIVITY_SERVICE.equals(name)) {
            	return getActivityManager();
          }
          else if (INPUT_METHOD_SERVICE.equals(name)) {
             	return InputMethodManager.getInstance(this);
          }
      }
      
      @Override
      public void startActivity(Intent intent) {
        	mMainThread.getInstrumentation().execStartActivity(
        		getOuterContext(),
        		mMainThread.getApplicationThread(),
        		null,
        		null,
        		intent,
        		-1,
        	);
      }
  }
  ```

  ​

* ContextWrapper， 

  ```
  public class ContextWrapper extends Context {
  	//该属性指向一个ContextImpl实例，一般在创建Application,Service,Activity时赋值
    	Context mBase; 
    	
    	protected void attachBaseContext(Context base) {
        	if (mBase != null) {
            	throw new IllegalStateException("Base context already set");
        	}
        	mBase = base;
    	}
    	
    	@Override
    	public void startActivity(Intent intent) {
        	mBase.startActivity(intent);
    	}
  }
  ```

* ContextThemeWrapper

  ```
  public class ContextThemeWrapper extends ContextWrapper {
    	private Context mBase;
    	
    	public ContextThemeWrapper(Context base, int themeres) {
        	super(base);
        	mBase = base;
        	mThemeResource = themeres;
    	}
    	
    	@Override
    	protected void attachBaseContext(Context newBase) {
        	super.attachBaseContext(newBase);
        	mBase = newBase;
    	}
  }
  ```



##### Context 作用域

* Activity 生成的Context拥有最大的作用域，这个和继承关系相关

##### Context 内存泄漏问题

一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败（如static对象的生命周期比较长，Context和这个关联起来之后，很容易出问题）

正确的使用：

* Application 的 Context能搞定的情况下，且生命周期比较长的对象，优先使用Application的Context
* 不要让生命周期长于Activity的对象持有Activity引用
* 尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐士持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有