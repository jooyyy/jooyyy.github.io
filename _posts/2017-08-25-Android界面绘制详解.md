---
layout:     post
title:      Android界面绘制详解
subtitle:   
date:       2017-08-25
author:     Joy
header-img: img/page-bg-people.png
catalog: true
tags:
    - Android
---

## Views 详解

* LayoutInflater用于加载布局，Activity中用得最多的setContentView()实质也是使用LayoutInflater来加载布局。

  LayoutInflater可以通过两种方式获取：

  ```
  LayoutInflater layoutInflater = LayoutInflater.from(context);

  LayoutInflater layoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

  // 然后通过inflate(resourceId, root)创建布局实例，然后添加到指定位置即可
  ```

  ​		

* 从源码的角度看一下LayoutInflater是如何工作的

  ```
  public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {  
      synchronized (mConstructorArgs) {  
          final AttributeSet attrs = Xml.asAttributeSet(parser);  
          mConstructorArgs[0] = mContext;  
          View result = root;  
          try {  
              int type;  
              while ((type = parser.next()) != XmlPullParser.START_TAG &&  
                      type != XmlPullParser.END_DOCUMENT) {  
              }  
              if (type != XmlPullParser.START_TAG) {  
                  throw new InflateException(parser.getPositionDescription()  
                          + ": No start tag found!");  
              }  
              final String name = parser.getName();  
              if (TAG_MERGE.equals(name)) {  
                  if (root == null || !attachToRoot) {  
                      throw new InflateException("merge can be used only with a valid "  
                              + "ViewGroup root and attachToRoot=true");  
                  }  
                  rInflate(parser, root, attrs);  
              } else {  
                  View temp = createViewFromTag(name, attrs);  
                  ViewGroup.LayoutParams params = null;  
                  if (root != null) {  
                      params = root.generateLayoutParams(attrs);  
                      if (!attachToRoot) {  
                          temp.setLayoutParams(params);  
                      }  
                  }  
                  rInflate(parser, temp, attrs);  
                  if (root != null && attachToRoot) {  
                      root.addView(temp, params);  
                  }  
                  if (root == null || !attachToRoot) {  
                      result = temp;  
                  }  
              }  
          } catch (XmlPullParserException e) {  
              InflateException ex = new InflateException(e.getMessage());  
              ex.initCause(e);  
              throw ex;  
          } catch (IOException e) {  
              InflateException ex = new InflateException(  
                      parser.getPositionDescription()  
                      + ": " + e.getMessage());  
              ex.initCause(e);  
              throw ex;  
          }  
          return result;  
      }  
  }  
  ```

  注意到createViewFromTag(name, attrs)方法，看名字应该可以猜到这里传了节点名和参数进去，得到了一个View返回，循环调用了rInflate()方法，源码如下：

  ```
  private void rInflate(XmlPullParser parser, View parent, final AttributeSet attrs)  
          throws XmlPullParserException, IOException {  
      final int depth = parser.getDepth();  
      int type;  
      while (((type = parser.next()) != XmlPullParser.END_TAG ||  
              parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {  
          if (type != XmlPullParser.START_TAG) {  
              continue;  
          }  
          final String name = parser.getName();  
          if (TAG_REQUEST_FOCUS.equals(name)) {  
              parseRequestFocus(parser, parent);  
          } else if (TAG_INCLUDE.equals(name)) {  
              if (parser.getDepth() == 0) {  
                  throw new InflateException("<include /> cannot be the root element");  
              }  
              parseInclude(parser, parent, attrs);  
          } else if (TAG_MERGE.equals(name)) {  
              throw new InflateException("<merge /> must be the root element");  
          } else {  
              final View view = createViewFromTag(name, attrs);  
              final ViewGroup viewGroup = (ViewGroup) parent;  
              final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);  
              rInflate(parser, view, attrs);  
              viewGroup.addView(view, params);  
          }  
      }  
      parent.onFinishInflate();  
  }  
  ```

  这样循环递归解析完xml之后，把View添加到父布局中。

#### 绘制流程

* onMeasure()
* onLayout()
* onDraw()

#### 视图状态

* enabled ，无法响应onTouch事件
* focused， 一般只有视图在focusable和focusable in touch mode 同时成立的情况下才能成功获取焦点
* selected，一个界面中可以有多个视图处于选中状态
* pressed

#### 自定义View

*  自绘控件

  > View上展现的内容全部都是我们自己绘制出来的，绘制的代码在onDraw()中

  简单来一段源码

  ```
  public class CounterView extends View implements OnClickListener {  
    
      private Paint mPaint;  
        
      private Rect mBounds;  
    
      private int mCount;  
        
      public CounterView(Context context, AttributeSet attrs) {  
          super(context, attrs);  
          mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
          mBounds = new Rect();  
          setOnClickListener(this);  
      }  
    
      @Override  
      protected void onDraw(Canvas canvas) {  
          super.onDraw(canvas);  
          mPaint.setColor(Color.BLUE);  
          canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);  
          mPaint.setColor(Color.YELLOW);  
          mPaint.setTextSize(30);  
          String text = String.valueOf(mCount);  
          mPaint.getTextBounds(text, 0, text.length(), mBounds);  
          float textWidth = mBounds.width();  
          float textHeight = mBounds.height();  
          canvas.drawText(text, getWidth() / 2 - textWidth / 2, getHeight() / 2  
                  + textHeight / 2, mPaint);  
      }  
    
      @Override  
      public void onClick(View v) {  
          mCount++;  
          invalidate();  
      }  
  }  
  ```

* 组合控件

  用系统原生的控件组合

* 继承控件

  ​

